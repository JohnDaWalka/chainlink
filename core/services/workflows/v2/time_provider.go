package v2

import (
	"time"

	"github.com/smartcontractkit/chainlink-common/pkg/logger"
	"github.com/smartcontractkit/chainlink-common/pkg/workflows/dontime"
)

const maxTimestampMillis = 4_200_000_000_000 // year 2103, used to avoid accidental int64 overflow

type TimeProvider interface {
	GetNodeTime() time.Time
	GetDONTime() (time.Time, error)
}

var _ TimeProvider = &DonTimeProvider{}

type DonTimeProvider struct {
	workflowExecutionID string
	timeSeqNum          int
	donTimeStore        *dontime.Store
	lggr                logger.Logger
}

func NewDonTimeProvider(store *dontime.Store, workflowExecutionID string, lggr logger.Logger) *DonTimeProvider {
	return &DonTimeProvider{
		workflowExecutionID: workflowExecutionID,
		timeSeqNum:          0,
		donTimeStore:        store,
		lggr:                logger.Named(lggr, "TimeProvider"),
	}
}

func (tp *DonTimeProvider) GetNodeTime() time.Time {
	return tp.fromUnixMilli(tp.donTimeStore.GetLastObservedDonTime())
}

// GetDONTime makes a request to the WorkflowLib plugin store for DON Time
func (tp *DonTimeProvider) GetDONTime() (time.Time, error) {
	defer func() {
		tp.timeSeqNum++
	}()

	donTimeResp := <-tp.donTimeStore.RequestDonTime(tp.workflowExecutionID, tp.timeSeqNum)
	if donTimeResp.Err != nil {
		// This node's request timed out, so it did not include the request in its observation.
		// However, consensus may still have been reached if other nodes included the request.
		if donTime := tp.donTimeStore.GetDonTimeForSeqNum(tp.workflowExecutionID, tp.timeSeqNum); donTime != nil {
			// Consensus was reached; return the DON time generated by the network.
			return tp.fromUnixMilli(*donTime), nil
		}
		tp.lggr.Errorf("No DON time reached for time call sequence %d on executionID %s; returning local node time as fallback. "+
			"This may result in non-deterministic behavior across nodes for this workflow step", tp.timeSeqNum, tp.workflowExecutionID)
		return tp.GetNodeTime(), nil
	}
	return tp.fromUnixMilli(donTimeResp.Timestamp), nil
}

func (tp *DonTimeProvider) fromUnixMilli(ms int64) time.Time {
	if ms > maxTimestampMillis {
		tp.lggr.Errorf("don time %d is greater than max allowed %d - truncating", ms, maxTimestampMillis)
		ms = maxTimestampMillis
	}
	return time.Unix(0, ms*int64(time.Millisecond)).UTC()
}
