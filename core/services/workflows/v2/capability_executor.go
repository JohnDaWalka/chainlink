package v2

import (
	"context"
	"fmt"
	"strconv"

	"github.com/smartcontractkit/chainlink-common/pkg/capabilities"
	sdkpb "github.com/smartcontractkit/chainlink-common/pkg/workflows/sdk/v2/pb"
	"github.com/smartcontractkit/chainlink-common/pkg/workflows/wasm/host"
	"github.com/smartcontractkit/chainlink/v2/core/platform"
	"github.com/smartcontractkit/chainlink/v2/core/services/keystore/keys/workflowkey"
	"github.com/smartcontractkit/chainlink/v2/core/services/workflows/events"
	"github.com/smartcontractkit/chainlink/v2/core/services/workflows/store"
)

var _ host.ExecutionHelper = (*ExecutionHelper)(nil)

type ExecutionHelper struct {
	*baseExecutionHelper
	*Engine
	WorkflowExecutionID string
	WorkflowOwner       string
	Key                 workflowkey.Key
}

func NewExecutionHelper(
	engine *Engine,
	workflowExecutionID string,
	workflowOwner string,
	key workflowkey.Key,
) *ExecutionHelper {
	return &ExecutionHelper{
		baseExecutionHelper: &baseExecutionHelper{
			Engine:              engine,
			WorkflowExecutionID: workflowExecutionID,
		},
		WorkflowExecutionID: workflowExecutionID,
		WorkflowOwner:       workflowOwner,
		Key:                 key,
	}
}

// CallCapability handles requests generated by the wasm guest
func (c *ExecutionHelper) CallCapability(ctx context.Context, request *sdkpb.CapabilityRequest) (*sdkpb.CapabilityResponse, error) {
	select {
	case c.capCallsSemaphore <- struct{}{}: // block if too many concurrent capability calls
	case <-ctx.Done():
		return nil, ctx.Err()
	}
	defer func() { <-c.capCallsSemaphore }()

	// TODO: if this needs to be extended to cover more extensions, consider
	// something more elegant like a middleware layer or a handler dispatcher.
	if request.Id == "vault@1.0.0" && request.Method == "GetSecrets" {
		v := &VaultOnlyExecutionHelper{
			baseExecutionHelper: c.baseExecutionHelper,
			WorkflowOwner:       c.WorkflowOwner,
			Key:                 c.Key,
		}
		return v.CallCapability(ctx, request)
	}

	return c.baseExecutionHelper.CallCapability(ctx, request)
}

type baseExecutionHelper struct {
	*Engine
	WorkflowExecutionID string
	TimeProvider
}

func (b *baseExecutionHelper) GetID() string {
	return b.WorkflowExecutionID
}

func (b *baseExecutionHelper) CallCapability(ctx context.Context, request *sdkpb.CapabilityRequest) (*sdkpb.CapabilityResponse, error) {
	// TODO (CAPPL-735): use request.Metadata.WorkflowExecutionId to associate the call with a specific execution
	capability, err := b.cfg.CapRegistry.GetExecutable(ctx, request.Id)
	if err != nil {
		return nil, fmt.Errorf("trigger capability not found: %w", err)
	}

	capReq := capabilities.CapabilityRequest{
		Payload:      request.Payload,
		Method:       request.Method,
		CapabilityId: request.Id,
		Metadata: capabilities.RequestMetadata{
			WorkflowExecutionID: b.WorkflowExecutionID,
		},
	}

	meterReport, ok := b.meterReports.Get(b.WorkflowExecutionID)
	if !ok {
		b.lggr.Errorf("no metering report found for %v", b.WorkflowExecutionID)
	}
	meteringRef := strconv.Itoa(int(request.CallbackId))

	// TODO: https://smartcontract-it.atlassian.net/browse/CRE-477 Get capability info by getting the workflow vertex and talking to the capaiblity

	// TODO: https://smartcontract-it.atlassian.net/browse/CRE-285 get max spend per step. Compare to availability and limits.

	availableForCall, err := meterReport.GetAvailableForInvocation(int(b.cfg.LocalLimits.MaxConcurrentCapabilityCallsPerWorkflow) - len(b.capCallsSemaphore))
	if err != nil {
		b.lggr.Errorw("could not reserve for capability request", "capReq", request.Id, "capReqCallbackID", request.CallbackId, "err", err)
	}

	// TODO: https://smartcontract-it.atlassian.net/browse/CRE-461 if availability is math.MaxInt64 there is no limit. Possibly flag this in a different way.

	err = meterReport.Deduct(meteringRef, availableForCall)
	if err != nil {
		b.cfg.Lggr.Errorw("could not deduct balance for capability request", "capReq", request.Id, "capReqCallbackID", request.CallbackId, "err", err)
	}

	// TODO: https://smartcontract-it.atlassian.net/browse/CRE-461
	// convert balance to CapabilityInfo resource types for use in Capability call
	// pass deducted amount as max spend to capability.Execute

	// TODO(CAPPL-737): run with a timeout
	b.lggr.Debugw("Executing capability ...", "capID", request.Id, "capReqCallbackID", request.CallbackId, "capReqMethod", request.Method)
	b.metrics.With(platform.KeyCapabilityID, request.Id).IncrementCapabilityInvocationCounter(ctx)
	_ = events.EmitCapabilityStartedEvent(ctx, b.loggerLabels, b.WorkflowExecutionID, request.Id, string(meteringRef))

	capResp, err := capability.Execute(ctx, capReq)
	if err != nil {
		b.lggr.Debugw("Capability execution failed", "capID", request.Id, "capReqCallbackID", request.CallbackId, "err", err)
		_ = events.EmitCapabilityFinishedEvent(ctx, b.loggerLabels, b.WorkflowExecutionID, request.Id, string(meteringRef), store.StatusErrored)
		b.metrics.With(platform.KeyCapabilityID, request.Id).IncrementCapabilityFailureCounter(ctx)
		b.metrics.IncrementTotalWorkflowStepErrorsCounter(ctx)
		return nil, fmt.Errorf("failed to execute capability: %w", err)
	}

	b.lggr.Debugw("Capability execution succeeded", "capID", request.Id, "capReqCallbackID", request.CallbackId)
	_ = events.EmitCapabilityFinishedEvent(ctx, b.loggerLabels, b.WorkflowExecutionID, request.Id, string(meteringRef), store.StatusCompleted)

	err = meterReport.Settle(meteringRef, capResp.Metadata.Metering)
	if err != nil {
		b.lggr.Errorw("failed to set metering for capability request", "capReq", request.Id, "capReqCallbackID", request.CallbackId, "err", err)
	}

	return &sdkpb.CapabilityResponse{
		Response: &sdkpb.CapabilityResponse_Payload{
			Payload: capResp.Payload,
		},
	}, nil
}
