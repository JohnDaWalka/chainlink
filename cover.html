
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>metering: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/smartcontractkit/chainlink/v2/core/services/workflows/metering/balance_store.go (88.9%)</option>
				
				<option value="file1">github.com/smartcontractkit/chainlink/v2/core/services/workflows/metering/metering.go (90.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package metering

import (
        "errors"
        "sync"

        "github.com/shopspring/decimal"

        "github.com/smartcontractkit/chainlink-common/pkg/logger"
)

var (
        ErrInsufficientBalance = errors.New("insufficient balance")
        ErrInvalidAmount       = errors.New("amount must be greater than 0")
)

type balanceStore struct {
        // meteringMode determines whether negative balances should return an error. meteringMode == true allows negative
        // balances.
        meteringMode bool
        // A balance of credits
        balance decimal.Decimal
        // Conversion rates of resource dimensions to number of units per credit
        conversions map[string]decimal.Decimal // TODO flip this
        lggr        logger.Logger
        mu          sync.RWMutex
}

type BalanceStore interface {
        Get() (balance int64)
        GetAs(unit string) (balance int64)
        Minus(amount int64) error
        MinusAs(unit string, amount int64) error
        Add(amount int64) error
        AddAs(unit string, amount int64) error
        AllowNegative()
}

var _ BalanceStore = (BalanceStore)(nil)

func NewBalanceStore(
        startingBalance decimal.Decimal,
        conversions map[string]decimal.Decimal,
        lggr logger.Logger,
) *balanceStore <span class="cov8" title="1">{
        // validations
        for resource, rate := range conversions </span><span class="cov8" title="1">{
                if rate.IsNegative() </span><span class="cov8" title="1">{
                        // fail open
                        lggr.Errorw("conversion rates must be a positive number, not using conversion", "resource", resource, "rate", rate)
                        delete(conversions, resource)
                }</span>
        }

        <span class="cov8" title="1">return &amp;balanceStore{
                meteringMode: false,
                balance:      startingBalance,
                conversions:  conversions,
                lggr:         lggr,
        }</span>
}

// convertToBalance converts a resource dimension amount to a credit amount.
// This method should only be used under a read lock.
func (bs *balanceStore) convertToBalance(fromUnit string, amount decimal.Decimal) decimal.Decimal <span class="cov8" title="1">{
        rate, ok := bs.conversions[fromUnit]
        if !ok </span><span class="cov8" title="1">{
                // Fail open, continue optimistically
                bs.lggr.Errorw("could not find conversion rate, continuing as 1:1", "unit", fromUnit)
                rate = decimal.NewFromInt(1)
                bs.meteringMode = true
        }</span>

        <span class="cov8" title="1">return amount.Mul(rate)</span>
}

// ConvertToBalance converts a resource dimensions amount to a credit amount.
func (bs *balanceStore) ConvertToBalance(fromUnit string, amount decimal.Decimal) decimal.Decimal <span class="cov8" title="1">{
        bs.mu.RLock()
        defer bs.mu.RUnlock()

        return bs.convertToBalance(fromUnit, amount)
}</span>

// convertFromBalance converts a credit amount to a resource dimensions amount.
// This method should only be used under a read lock.
func (bs *balanceStore) convertFromBalance(toUnit string, amount decimal.Decimal) decimal.Decimal <span class="cov8" title="1">{
        rate, ok := bs.conversions[toUnit]
        if !ok </span><span class="cov8" title="1">{
                // Fail open, continue optimistically
                bs.lggr.Errorw("could not find conversion rate, continuing as 1:1", "unit", toUnit)
                rate = decimal.NewFromInt(1)
        }</span>

        <span class="cov8" title="1">decimal.DivisionPrecision = defaultDecimalPrecision

        return amount.Div(rate)</span>
}

// ConvertFromBalance converts a credit amount to a resource dimensions amount.
func (bs *balanceStore) ConvertFromBalance(toUnit string, amount decimal.Decimal) decimal.Decimal <span class="cov0" title="0">{
        bs.mu.RLock()
        defer bs.mu.RUnlock()

        return bs.convertFromBalance(toUnit, amount)
}</span>

// Get returns the current credit balance
func (bs *balanceStore) Get() decimal.Decimal <span class="cov8" title="1">{
        bs.mu.RLock()
        defer bs.mu.RUnlock()

        return bs.balance
}</span>

// GetAs returns the current universal credit balance expressed as a resource dimensions.
func (bs *balanceStore) GetAs(unit string) decimal.Decimal <span class="cov8" title="1">{
        bs.mu.RLock()
        defer bs.mu.RUnlock()

        if bs.balance.LessThanOrEqual(decimal.Zero) </span><span class="cov8" title="1">{
                return decimal.Zero
        }</span>

        <span class="cov8" title="1">return bs.convertFromBalance(unit, bs.balance)</span>
}

// Minus lowers the current credit balance.
func (bs *balanceStore) Minus(amount decimal.Decimal) error <span class="cov8" title="1">{
        bs.mu.Lock()
        defer bs.mu.Unlock()

        if amount.LessThanOrEqual(decimal.Zero) </span><span class="cov0" title="0">{
                return ErrInvalidAmount
        }</span>

        <span class="cov8" title="1">if amount.GreaterThan(bs.balance) &amp;&amp; !bs.meteringMode </span><span class="cov8" title="1">{
                return ErrInsufficientBalance
        }</span>

        <span class="cov8" title="1">bs.balance = bs.balance.Sub(amount)

        return nil</span>
}

// MinusAs lowers the current credit balance based on an amount of resource dimensions.
func (bs *balanceStore) MinusAs(unit string, amount decimal.Decimal) error <span class="cov8" title="1">{
        bs.mu.Lock()
        defer bs.mu.Unlock()

        if amount.LessThanOrEqual(decimal.Zero) </span><span class="cov0" title="0">{
                return ErrInvalidAmount
        }</span>

        <span class="cov8" title="1">balToMinus := bs.convertToBalance(unit, amount)

        if balToMinus.GreaterThan(bs.balance) &amp;&amp; !bs.meteringMode </span><span class="cov0" title="0">{
                return ErrInsufficientBalance
        }</span>

        <span class="cov8" title="1">bs.balance = bs.balance.Sub(balToMinus)

        return nil</span>
}

// Add increases the current credit balance.
func (bs *balanceStore) Add(amount decimal.Decimal) error <span class="cov8" title="1">{
        bs.mu.Lock()
        defer bs.mu.Unlock()

        if amount.LessThan(decimal.Zero) </span><span class="cov8" title="1">{
                return ErrInvalidAmount
        }</span>

        <span class="cov8" title="1">bs.balance = bs.balance.Add(amount)

        return nil</span>
}

// AddAs increases the current credit balance based on an amount of resource dimensions.
func (bs *balanceStore) AddAs(unit string, amount decimal.Decimal) error <span class="cov8" title="1">{
        bs.mu.Lock()
        defer bs.mu.Unlock()

        if amount.LessThanOrEqual(decimal.Zero) </span><span class="cov0" title="0">{
                return ErrInvalidAmount
        }</span>

        <span class="cov8" title="1">bs.balance = bs.balance.Add(bs.convertToBalance(unit, amount))

        return nil</span>
}

// AllowNegative turns on the flag to allow negative balances.
func (bs *balanceStore) AllowNegative() <span class="cov8" title="1">{
        bs.mu.Lock()
        defer bs.mu.Unlock()

        bs.meteringMode = true
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package metering

import (
        "context"
        "errors"
        "fmt"
        "sort"
        "sync"

        "github.com/shopspring/decimal"

        "github.com/smartcontractkit/chainlink-common/pkg/capabilities"
        "github.com/smartcontractkit/chainlink-common/pkg/logger"
        billing "github.com/smartcontractkit/chainlink-protos/billing/go"
        "github.com/smartcontractkit/chainlink-protos/workflows/go/events"
)

const (
        ComputeResourceDimension = "COMPUTE"
        defaultDecimalPrecision  = 3 // one thousandth of a dollar
)

var (
        ErrNoBillingClient     = errors.New("no billing client has been configured")
        ErrInsufficientFunding = errors.New("insufficient funding")
        ErrReceiptFailed       = errors.New("failed to submit workflow receipt")
        ErrNoReserve           = errors.New("must call Reserve first")
        ErrStepDeductExists    = errors.New("step deduct already exists")
        ErrNoOpenCalls         = errors.New("openConcurrentCallSlots must be greater than 0")
        ErrNoDeduct            = errors.New("must call Deduct first")
        ErrStepSpendExists     = errors.New("step spend already exists")
        ErrReportNotFound      = errors.New("report not found")
        ErrReportExists        = errors.New("report already exists")
)

type BillingClient interface {
        SubmitWorkflowReceipt(context.Context, *billing.SubmitWorkflowReceiptRequest) (*billing.SubmitWorkflowReceiptResponse, error)
        ReserveCredits(context.Context, *billing.ReserveCreditsRequest) (*billing.ReserveCreditsResponse, error)
}

type SpendTuple struct {
        Unit  string
        Value decimal.Decimal
}

type ProtoDetail struct {
        Schema string
        Domain string
        Entity string
}

type ReportStep struct {
        // The maximum amount of universal credits that should be used in this step
        Deduction decimal.Decimal
        // The actual resource spend that each node used for this step
        Spends map[string][]ReportStepDetail
}

type ReportStepDetail struct {
        Peer2PeerID string
        SpendValue  string
}

type Report struct {
        // descriptive properties
        owner               string
        workflowID          string
        workflowExecutionID string

        // dependencies
        balance *balanceStore
        client  BillingClient
        lggr    logger.Logger

        // internal state
        ready bool
        mu    sync.RWMutex
        steps map[string]ReportStep
}

func NewReport(owner, workflowID, workflowExecutionID string, lggr logger.Logger, client BillingClient) *Report <span class="cov8" title="1">{
        sLggr := logger.Sugared(lggr).Named("Metering").With("workflowExecutionID", workflowExecutionID)

        return &amp;Report{
                owner:               owner,
                workflowID:          workflowID,
                workflowExecutionID: workflowExecutionID,

                balance: NewBalanceStore(decimal.Zero, map[string]decimal.Decimal{}, sLggr),
                client:  client,
                lggr:    sLggr,

                ready: false,
                steps: make(map[string]ReportStep),
        }
}</span>

// Reserve calls the billing service for the initial credit balance that can be used in an execution.
// This method must be called before Deduct or Settle.
func (r *Report) Reserve(ctx context.Context) error <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if r.client == nil </span><span class="cov8" title="1">{
                r.lggr.Error("billing client not set; switching to metering mode")
                r.balance.meteringMode = true
                r.ready = true

                return nil
        }</span>

        // TODO: https://smartcontract-it.atlassian.net/browse/CRE-427 more robust check of billing service health

        // If there is no credit limit defined in the workflow, then open an empty reservation
        // TODO: https://smartcontract-it.atlassian.net/browse/CRE-284 consume user defined workflow execution limit
        <span class="cov8" title="1">req := billing.ReserveCreditsRequest{
                AccountId:           r.owner,
                WorkflowId:          r.workflowID,
                WorkflowExecutionId: r.workflowExecutionID,
                Credits:             0,
        }

        resp, err := r.client.ReserveCredits(ctx, &amp;req)

        // If there is an error communicating with the billing service, fail open
        if err != nil </span><span class="cov8" title="1">{
                r.lggr.Warnf("failed to reserve credits; switching to metering mode: %s", err)
                r.balance.meteringMode = true
                r.ready = true

                return nil
        }</span>

        <span class="cov8" title="1">if success := resp.GetSuccess(); !success </span><span class="cov8" title="1">{
                return ErrInsufficientFunding
        }</span>

        <span class="cov8" title="1">rateCard, err := toRateCard(resp.GetRates())
        if err != nil </span><span class="cov0" title="0">{
                r.lggr.Warnf("failed to parse rate card; switching to metering mode: %s", err)
                r.balance.meteringMode = true
                r.ready = true

                return nil
        }</span>

        <span class="cov8" title="1">r.ready = true
        r.balance = NewBalanceStore(decimal.NewFromFloat32(resp.Credits), rateCard, r.lggr)

        return nil</span>
}

// ConvertToBalance converts a resource dimensions amount to a credit amount.
func (r *Report) ConvertToBalance(fromUnit string, amount decimal.Decimal) (decimal.Decimal, error) <span class="cov8" title="1">{
        if !r.ready </span><span class="cov8" title="1">{
                return decimal.Zero, ErrNoReserve
        }</span>

        <span class="cov8" title="1">return r.balance.ConvertToBalance(fromUnit, amount), nil</span>
}

// Deduct earmarks an amount of local universal credit balance. We expect to only set this value once - an error is
// returned if a step would be overwritten. Deduct expects a NullDecimal because GetMaxSpendForInvocation can return
// a NullDecimal.
func (r *Report) Deduct(ref string, amount decimal.NullDecimal) error <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if !r.ready </span><span class="cov8" title="1">{
                return ErrNoReserve
        }</span>

        <span class="cov8" title="1">if _, ok := r.steps[ref]; ok </span><span class="cov8" title="1">{
                return ErrStepDeductExists
        }</span>

        <span class="cov8" title="1">r.steps[ref] = ReportStep{
                Deduction: amount.Decimal,
                Spends:    nil,
        }

        // if in metering mode, exit early without modifying local balance
        if r.balance.meteringMode || !amount.Valid </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">err := r.balance.Minus(amount.Decimal)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *Report) CreditToSpendingLimits(
        info capabilities.CapabilityInfo,
        amount decimal.Decimal,
) []capabilities.SpendLimit <span class="cov0" title="0">{
        if len(info.SpendTypes) &gt; 0 </span><span class="cov0" title="0">{
                spendType := info.SpendTypes[0]

                // use rate card to convert capSpendLimit to native units
                spendLimit := r.balance.ConvertFromBalance(string(spendType), amount)

                // check to see if metering mode is active
                if r.balance.meteringMode </span><span class="cov0" title="0">{
                        r.lggr.Errorf("no rate exists in rate card for %s; entering metering mode", spendType)

                        return nil
                }</span>

                <span class="cov0" title="0">return []capabilities.SpendLimit{{SpendType: spendType, Limit: spendLimit.StringFixed(defaultDecimalPrecision)}}</span> // TODO: should we apply rounding? maybe take only the int part?
        }

        <span class="cov0" title="0">return nil</span>
}

// GetMaxSpendForInvocation returns the amount of credits that can be used based on the minimum between and optionally
// provided max spend by the user or the available credit balance. The available credit balance is determined by
// dividing unearmarked local credit balance by the number of potential concurrent calls.
func (r *Report) GetMaxSpendForInvocation(
        ref string,
        userSpendLimit decimal.NullDecimal,
        openConcurrentCallSlots int,
) (decimal.NullDecimal, error) <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        capSpendLimit := decimal.NewNullDecimal(decimal.Zero)
        capSpendLimit.Valid = false

        if openConcurrentCallSlots == 0 </span><span class="cov8" title="1">{
                // invariant: this should be managed by the consumer (engine)
                return capSpendLimit, ErrNoOpenCalls
        }</span>

        <span class="cov8" title="1">if !r.ready </span><span class="cov8" title="1">{
                return capSpendLimit, ErrNoReserve
        }</span>

        <span class="cov8" title="1">if r.balance.meteringMode </span><span class="cov8" title="1">{
                return capSpendLimit, nil
        }</span>

        <span class="cov8" title="1">decimal.DivisionPrecision = defaultDecimalPrecision

        // Split the available local balance between the number of concurrent calls that can still be made
        capSpendLimit.Decimal = r.balance.Get().Div(decimal.NewFromInt(int64(openConcurrentCallSlots)))

        if userSpendLimit.Valid </span><span class="cov8" title="1">{
                capSpendLimit.Decimal = decimal.Min(capSpendLimit.Decimal, userSpendLimit.Decimal)
        }</span>

        <span class="cov8" title="1">capSpendLimit.Valid = true

        return capSpendLimit, nil</span>
}

// Settle handles the actual spends that each node used for a given capability invocation in the engine,
// by returning earmarked local balance to the available to use pool and adding the spend to the metering report.
// The Deduct method must be called before Settle.
// We expect to only set this value once - an error is returned if a step would be overwritten.
func (r *Report) Settle(ref string, spendsByNode []capabilities.MeteringNodeDetail) error <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        if !r.ready </span><span class="cov8" title="1">{
                return ErrNoReserve
        }</span>

        <span class="cov8" title="1">step, ok := r.steps[ref]
        if !ok </span><span class="cov8" title="1">{
                return ErrNoDeduct
        }</span>

        <span class="cov8" title="1">if step.Spends != nil </span><span class="cov8" title="1">{
                return ErrStepSpendExists
        }</span>

        <span class="cov8" title="1">spentCredits := decimal.NewFromInt(0)
        resourceSpends := make(map[string][]ReportStepDetail)

        // Group by resource dimension
        for _, nodeDetail := range spendsByNode </span><span class="cov8" title="1">{
                resourceSpends[nodeDetail.SpendUnit] = append(resourceSpends[nodeDetail.SpendUnit], ReportStepDetail{
                        Peer2PeerID: nodeDetail.Peer2PeerID,
                        SpendValue:  nodeDetail.SpendValue,
                })
        }</span>

        // Aggregate node responses to a single number
        <span class="cov8" title="1">for unit, spendDetails := range resourceSpends </span><span class="cov8" title="1">{
                deciVals := []decimal.Decimal{}
                for _, detail := range spendDetails </span><span class="cov8" title="1">{
                        value, err := decimal.NewFromString(detail.SpendValue)
                        if err != nil </span><span class="cov8" title="1">{
                                r.lggr.Error(fmt.Sprintf("failed to get spend value from %s: %s", detail.SpendValue, err))
                                // throw out invalid values for local balance settlement. they will still be included in metering report.
                                continue</span>
                        }

                        <span class="cov8" title="1">deciVals = append(deciVals, value)</span>
                }

                <span class="cov8" title="1">aggregateSpend := medianSpend(deciVals)
                spentCredits = spentCredits.Add(r.balance.ConvertToBalance(unit, aggregateSpend))</span>
        }

        <span class="cov8" title="1">step.Spends = resourceSpends
        r.steps[ref] = step

        // if in metering mode, exit early without modifying local balance
        if r.balance.meteringMode </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Refund the difference between what local balance had been earmarked and the actual spend
        <span class="cov8" title="1">if err := r.balance.Add(step.Deduction.Sub(spentCredits)); err != nil </span><span class="cov8" title="1">{
                // invariant: capability should not let spend exceed reserve
                r.lggr.Error("invariant: spend exceeded reserve")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *Report) FormatReport() *events.MeteringReport <span class="cov8" title="1">{
        protoReport := &amp;events.MeteringReport{
                Steps:    map[string]*events.MeteringReportStep{},
                Metadata: &amp;events.WorkflowMetadata{},
        }

        for ref, step := range r.steps </span><span class="cov8" title="1">{
                nodeDetails := []*events.MeteringReportNodeDetail{}

                for unit, details := range step.Spends </span><span class="cov8" title="1">{
                        for _, detail := range details </span><span class="cov8" title="1">{
                                nodeDetails = append(nodeDetails, &amp;events.MeteringReportNodeDetail{
                                        Peer_2PeerId: detail.Peer2PeerID,
                                        SpendUnit:    unit,
                                        SpendValue:   detail.SpendValue,
                                })
                        }</span>
                }

                <span class="cov8" title="1">protoReport.Steps[ref] = &amp;events.MeteringReportStep{
                        Nodes: nodeDetails,
                }</span>
        }

        <span class="cov8" title="1">return protoReport</span>
}

func (r *Report) SendReceipt(ctx context.Context) error <span class="cov8" title="1">{
        if !r.ready </span><span class="cov8" title="1">{
                return ErrNoReserve
        }</span>

        <span class="cov8" title="1">if r.client == nil </span><span class="cov8" title="1">{
                return ErrNoBillingClient
        }</span>

        // TODO: https://smartcontract-it.atlassian.net/browse/CRE-427 more robust check of billing service health

        <span class="cov8" title="1">req := billing.SubmitWorkflowReceiptRequest{
                AccountId:           r.owner,
                WorkflowId:          r.workflowID,
                WorkflowExecutionId: r.workflowExecutionID,
                Metering:            r.FormatReport(),
        }

        resp, err := r.client.SubmitWorkflowReceipt(ctx, &amp;req)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if resp == nil || !resp.Success </span><span class="cov8" title="1">{
                return ErrReceiptFailed
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func toRateCard(rates []*billing.ResourceUnitRate) (map[string]decimal.Decimal, error) <span class="cov8" title="1">{
        rateCard := map[string]decimal.Decimal{}
        for _, rate := range rates </span><span class="cov8" title="1">{
                conversionDeci, err := decimal.NewFromString(rate.ConversionRate)
                if err != nil </span><span class="cov0" title="0">{
                        return map[string]decimal.Decimal{}, fmt.Errorf("could not convert unit %s's value %s to decimal", rate.ResourceUnit, rate.ConversionRate)
                }</span>
                <span class="cov8" title="1">rateCard[rate.ResourceUnit] = conversionDeci</span>
        }
        <span class="cov8" title="1">return rateCard, nil</span>
}

func medianSpend(spends []decimal.Decimal) decimal.Decimal <span class="cov8" title="1">{
        sort.Slice(spends, func(i, j int) bool </span><span class="cov8" title="1">{
                return spends[j].GreaterThan(spends[i])
        }</span>)

        <span class="cov8" title="1">if len(spends)%2 &gt; 0 </span><span class="cov8" title="1">{
                return spends[len(spends)/2]
        }</span>

        <span class="cov8" title="1">return spends[len(spends)/2-1].Add(spends[len(spends)/2]).Div(decimal.NewFromInt(2))</span>
}

// Reports is a concurrency-safe wrapper around map[string]*Report.
type Reports struct {
        mu      sync.RWMutex
        reports map[string]*Report
        client  BillingClient
        lggr    logger.Logger

        // descriptive properties
        owner      string
        workflowID string
}

// NewReports initializes and returns a new Reports.
func NewReports(client BillingClient, owner, workflowID string, lggr logger.Logger) *Reports <span class="cov8" title="1">{
        return &amp;Reports{
                reports: make(map[string]*Report),
                client:  client,

                lggr: lggr,

                owner:      owner,
                workflowID: workflowID,
        }
}</span>

// Get retrieves a Report for a given workflowExecutionID (if it exists).
func (s *Reports) Get(workflowExecutionID string) (*Report, bool) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        val, ok := s.reports[workflowExecutionID]
        return val, ok
}</span>

// Start creates a new report and inserts it under the specified workflowExecutionID.
func (s *Reports) Start(ctx context.Context, workflowExecutionID string) (*Report, error) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        _, ok := s.reports[workflowExecutionID]
        if ok </span><span class="cov8" title="1">{
                return nil, ErrReportExists
        }</span>

        <span class="cov8" title="1">report := NewReport(s.owner, s.workflowID, workflowExecutionID, s.lggr, s.client)

        s.reports[workflowExecutionID] = report

        return report, nil</span>
}

// End removes the Report with the specified workflowExecutionID.
func (s *Reports) End(ctx context.Context, workflowExecutionID string) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        report, ok := s.reports[workflowExecutionID]
        if !ok </span><span class="cov8" title="1">{
                return ErrReportNotFound
        }</span>

        // if in metering mode, send to beholder

        <span class="cov8" title="1">err := report.SendReceipt(ctx)

        delete(s.reports, workflowExecutionID)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *Reports) Len() int <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        return len(s.reports)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
